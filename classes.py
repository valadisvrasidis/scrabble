# import dependencies
import random # η βιβλιοθήκη για τον χειρισμό τυχαίων αριθμών
import os # η βιβλιοθήκη για τον έλεγχο του συστήματος. Εμείς την χρησιμοποιούμε για την συνάρτηση os.path.exists(filename) η όποια επιστρέφει αν υπάρχει η διαδρομή ενός αρχείου
from utils import findsubsets, findrearranges, save_json, load_json # εισάγουμε τις βοηθητικές συναρτήσεις από το αρχείο utils. Το κάναμε για να μείνει ο κώδικας όσο το δυνατόν πιο ευανάγνωστος και εύκολος στην κατανόηση
#στην μεταβλητή lets είναι αποθηκευμένα τα γράμματα μαζί με τις αντίστοιχες αξίες τους όπως αναφέρεται στις διαφάνειες του μαθήματος
lets = {'Α': [12, 1], 'Β': [1, 8], 'Γ': [2, 4], 'Δ': [2, 4], 'Ε': [8, 1], 'Ζ': [1, 10], 'Η': [7, 1], 'Θ': [1, 10], 'Ι': [1, 10], 'Κ': [4, 2], 'Λ': [3, 3], 'Μ': [3, 3], 'Ν': [6, 1], 'Ξ': [1, 10], 'Ο': [9, 1], 'Π': [4, 2], 'Ρ': [5, 2], 'Σ': [7, 1], 'Τ': [8, 1], 'Υ': [4, 2], 'Φ': [1, 8], 'Χ': [1, 8], 'Ψ': [1, 10], 'Ω': [3, 3]} #
# τα έγκυρα γράμματα του scrabble για την Ελληνική Γλώσσα όπως στις διαφάνειες επεξήγησης

class Regulator():
    """
    Η συγκεκριμένη κλάση είναι υπεύθυνη για τον έλεγχο των λέξεων με το διάβασμα του αρχείου των έγκυρων λέξεων greek7.txt. Η συγκεκριμένη κλάση δέχεται σαν είσοδο
    την θέση του αρχείου greek7.txt η όποια έχει ως default τιμή: 'greek7.txt', δηλαδή το αρχείο βρίσκεται στον ίδιο φάκελο με τον υπόλοιπο κώδικα.
    """
    def __init__(self, filename = "greek7.txt"):
        """
            Η συγκεκριμένη συνάρτηση καλείται κατασκευάζεται ένα στιγμιότυπο της κλάσης Regulator. Η συνάρτηση δέχεται ως είσοδο μια παράμετρο:
            filename με default τιμή την 'greek7.txt'.
            Η συγκεκριμένη συνάρτηση, διαβάζει το αρχείο με τις λέξεις τις Ελληνικής αποθηκεύοντας τες σε μια δομή τύπου DICTIONARY και όχι λίστας.
            Έτσι μπορεί με πολύ γρήγορο τρόπο να ελέγχει αν μια λέξη ανήκει στο σύνολο των έγκυρων λέξεων μιας και ο μέσος χρόνος αναζήτησης σε μια τέτοια δομή είναι Θ(1).
        """
        self.filename = filename
        self.words = set()
        with open(filename, "r", encoding = "utf-8") as f:
            words = f.readlines()
            for word in words:
                self.words.add(word.strip())

    def checkword(self, player_lets, word):
        """
        Η συγκεκριμένη μέθοδος δέχεται σαν είσοδο:
        1. με λίστα με τα γράμματα του παίχτη
        2. μια λέξη
        και επιστρέφει αν η λέξη είναι έγκυρη το σκορ της μαζί με κατάλληλο μήνυμα. Αν η λέξη δεν είναι έγκυρη επιστρέφει σαν σκορ 0 και επίσης μήνυμα που εξηγεί
        τους λόγους για τους όποιους η λέξη δεν είναι έγκυρη π.χ. λάθος γράμματα ή μη αποδεκτή λέξη (από το αρχείο greek7.txt)
        """
        score = 0
        word = word.upper() # κάνουμε τα γράμματα κεφάλαια ώστε να μην είμαστε case sensitive ως προς την λέξη. Αυτό πρακτικά σημαίνει ότι είτε ο παίχτης εισάγει την λέξη 'πάμε' ή 'ΠάΜε' θα αντιμετωπίζεται ως το ίδιο
        player_lets_copy = player_lets.copy()
        for let in word: # για κάθε γράμμα της λέξης
            if let not in player_lets_copy: # αν το γράμμα δεν είναι μέσα στο σύνολο των γραμμάτων του παίχτη επιστρέφεις λάθος
                return 0, f"Πρέπει να χρησιμοποιήσεις αποκλειστικά τα γράμματα που σου δόθηκαν! Το {let} δεν ανήκει σε αυτά!"
            player_lets_copy.remove(let) # αφαιρούμε κάθε γράμμα από το αντίγραφο του πλακιδίου
            score += lets.get(let)[1] # προσθέτουμε το σκορ του γράμματος στο συνολικό σκορ της λέξης
        if word not in self.words: # αν η λέξη δεν ανήκει στο σύνολο των λέξεων του αρχείου greek7.txt τότε δεν είναι αποδεκτή λέξη
            return 0, f"Δυστυχώς η λέξη: {word} φαίνεται να μην υπάρχει! Δοκίμασε με άλλη λέξη!" # οπότε επιστρέφουν 0 σαν σκορ και το αντίστοιχο μήνυμα
        if len(word) == 7:
            score += 50 # αν ο παίχτης χρησιμοποίησε όλα τα γράμματα τότε στο σκορ προστίθενται 50 πόντοι που είναι το σκορ του scrabble
        return score, f"Αποδεκτή Λέξη - Βαθμοί: {score}"


class SakClass:
    def __init__(self):
        """
        Η συνάρτηση αυτή καλείται ότι κατασκευάζεται ένα στιγμιότυπο της κλάσης SakClass που προσομοιώνει την λειτουργία από το σακουλάκι μετά γράμματα στο φυσικό παιχνίδι
        Το σακουλάκι ουσιαστικά υλοποιείται μέσω μιας λίστας στην οποία αποθηκεύονται το κάθε γράμμα για όσες φορές υπάρχει στο παιχνίδι. Οπότε αρχικά έχουμε μια λίστα
        με όλα τα πλακίδια μέσα ακριβώς όπως στο φυσικό παιχνίδι την όποια στην συνέχεια την ανακατευούμε ώστε τα γράμματα να τοποθετηθούν σε τυχαίες θέσεις.
        """
        self.sak = []
        for let, [num, times] in lets.items(): # για κάθε γράμμα της λίστας lets
            self.sak += [let] * num # το τοποθετούμε στην λίστα τις αντίστοιχες φορές που εμφανίζονται
        random.shuffle(self.sak) # τέλος ανακατευούμε το σακουλάκι με τα γράμματα όπως ακριβώς και στο φυσκό παιχνίδι

    def __repr__(self):
        """
        Η μέθοδος αυτή επιστρέφει κατάλληλο μήνυμα για κάθε στιγμιότυπο της κλάσης SakClass
        """
        return f"Στο σακουλάκι υπάρχουν {self.saksize()}"

    def randomize_sak(self, number_of_lets):
        """
        Η συγκεκριμένη μέθοδος επιλέγει έναν τυχαίο αριθμό γραμμάτων από το σακουλάκι. Έτσι προσομοιώνει το χέρι του παίχτη το όποιο εισέρχεται στο σακουλάκι και επιλέγει
        πλακίδια, πριν όμως τα αφαιρέσει από το σακουλάκι.
        Είσοδος: Ο αριθμός των γραμμάτων που θέλουμε να επιλέξουμε.
        Έξοδος: Τα γράμματα που επιλέχθηκαν τυχαία.
        Αξίζει να σημειωθεί ότι η μέθοδος αυτή δεν αφαιρεί τα γράμματα από το σακουλάκι, απλά επιλέγει ορισμένα!
        Τέλος αν ο αριθμός των γραμμάτων που θέλουμε είναι μεγαλύτερος από τα εναπομείναντα γράμματα επιστρέφει κωδικό για την λήξη του παιχνιδιού!
        """
        if len(self.sak) < number_of_lets:
            raise Exception ("Το παιχνίδι έληξε γιατί το σακουλάκι άδειασε! Δεν υπάρχουν αρκετά γράμματα να αντικαταστήσουν αυτά που βγήκαν!")
        return random.sample(self.sak, number_of_lets) # χρησιμοποιούμε την βιβλιοθήκη random για την επιλογή τυχαίων γραμμάτων από την λίστα - σακουλάκι

    def putbackletters(self, lets):
        """
        Η μέθοδος αυτή επιστρέφει τα γράμματα στο σακουλάκι.
        Είσοδος: μια λίστα με γράμματα
        Έξοδος: Τίποτα
        """
        self.sak += lets # στο σακουλάκι προσθέτουμε και τα νέα γράμματα

    def getletters(self, number_of_lets):
        """
        Μέθοδος η οποία παρέχει στον παίχτη ορισμένα τυχαία γράμματα από το σακουλάκι. Τα γράμματα που επιστρέφονται εξάγονται και από το σακουλάκι (σε αντίθεση με την μέθοδο randomize_sak)
        Είσοδος: Αριθμός γραμμάτων που θέλουμε να εξάγουμε από το σακουλάκι
        Έξοδος: Τα γράμματα που επιλέχθηκαν τυχαία
        Η διαφορά με την randomize_sak είναι ότι εδώ τα γράμματα που μας δίνει η randomize_sak αφαιρούνται από το σακουλάκι!
        Η μέθοδος αυτή χρησιμοποιεί την randomize_sak για την επιλογή των γραμμάτων.
        """
        player_lets = self.randomize_sak(number_of_lets)
        # αφαιρούμε τα γράμματα από το σακουλάκι
        for let in player_lets:
            self.sak.remove(let) # αφαιρούμε το γράμμα από το σακουλάκι
        # και επιστρέφουμε τα επιλεγμένα γράμματα στον παίχτη
        return player_lets

    def saksize(self):
        return len(self.sak)



class Rack:
    """
    Η κλάση αυτή προσομοιώνει την λειτουργία του δίσκου στο όποιο οι παίχτες τοποθετούν τα πλακίδιά τους κατά την διάρκεια του παιχνιδιού.
    Έτσι έχει μια λίστα η όποια αρχικά είναι κενή και μια μεταβλητή η όποια αποθηκεύει τα γράμματα που εισήχθησαν τελευταία στον δίσκο
    Αυτό το κάνουμε για να μπορούμε να αναιρέσουμε την τελευταία πράξη, όπως στην περίπτωση του πάσου!
    """
    def __init__(self):
        """
        Η μέθοδος αυτή καλείται κάθε φορά που κατασκευάζεται ένα στιγμιότυπο τύπου Rack και ουσιαστικά
        αρχικοποιεί το πλακίδιο και την λίστα της τελευταίας εισαγωγής με μια λίστα με κενά!
        Είσοδος: Κένο
        """
        self.rack = [None, None, None, None, None, None, None]
        self.last_lets = []

    def __repr__(self):
        """
        Η μέθοδος αυτή επιστρέφει ένα str με τα δεδομένα του πλακιδίου, όπως αυτά θέλουμε να τυπώνονται
        κατά την διάρκεια του παιχνιδιού
        """
        txt = "Διαθέσιμα Γράμματα: " # αρχικοποιούμε το str
        for let in self.rack[:-1]: # για κάθε ένα πλακίδιο του δίσκου, εκτός τους τελευταίου
            txt += f"{let}, {lets.get(let)[1]} - " # βάλε το γράμμα και την αξία του και στο τέλος μια -
        let = self.rack[-1] # για το τελευταίο γράμμα
        txt += f"{let}, {lets.get(let)[1]}" # βάλε το γράμμα και την αξία του χωρίς όμως την -
        return txt


    def add_tiles(self, new_lets):
        """
        Η μέθοδος αυτή προσθέτει μια λίστα από γράμματα στον δίσκο, π.χ. τα γράμματα που έχουμε τραβήξει από το σακουλάκι
        Τα γράμματα αυτά τα τοποθετεί στις θέσεις που είναι κενές! Έτσι όταν βγάζουμε από τον δίσκο και γράμματα π.χ. για
        να τα βάλουμε για μια λέξη τότε τα νέα γράμματα θα τοποθετηθούν στις θέσεις των παλαιών!
        Αυτός ο τρόπος παρατηρήσαμε ότι είναι πολύ πιο εύκολος για την κατανόηση- έλεγχο από τον χρήστη - παίχτη,
        μιας και οι θέσεις των παλαιών γραμμάτων δεν αλλάζουν και έτσι μπορεί να κρατάει μια ροή! Αυτός είναι και ο κύριος
        λόγος που υλοποιήσαμε όλη αυτήν την κλάση, για να κάνουμε αυτές τις ενέργειες πιο κατανοητές και πιο εύκολες!
        Είσοδος: Μια λίστα με γράμματα
        Έξοδος: Κενό
        """
        j = 0 # η θέση που είμαστε στα νέα γράμματα
        for i, let in enumerate(self.rack): # για κάθε γράμμα του πλακιδίου
            if let == None: # αν στην θέση αυτή έχουμε κενό - None
                self.rack[i] = new_lets[j] # τότε σε αυτήν την θέση βάζουμε το νέο γράμμα της λίστας των νέων γραμμάτων
                j += 1 # μετακινούμε τον δείκτη της λίστας τον νέων γραμμάτων κατά μια θέση προς τα δεξιά
        self.last_lets = new_lets # αφού εισάγουμε τα νέα γράμματα αποθηκεύουμε στην κλάση μας τα γράμματα που προστέθηκαν τελευταία

    def remove_tiles(self, lets):
        """
        Η μέθοδος αυτή αφαιρεί πλακίδια από τον δίσκο, βάζοντας στις αντίστοιχές θέσεις τους κενό.
        Είσοδος: Η λίστα των γραμμάτων που θέλουμε να αφαιρέσουμε
        Έξοδος: Κενό
        """
        for let in lets: # για κάθε ένα από τα γράμματα του θέλουμε να αφαιρέσουμε
            index = self.rack.index(let) # βρίσκουμε την θέση του στον δίσκο
            self.rack[index] = None # και σε αυτήν την θέση βάζουμε κενό

    def rollback(self):
        """
        Η μέθοδος αυτή αναλαμβάνει την αφαίρεση των τελευταίων γραμμάτων που εισήχθησαν στον δίσκο
        Είσοδος: Κενό
        Έξοδος: Η λίστα με τα τελευταία γράμματα που είχαν προστεθεί στον δίσκο
        """
        self.remove_tiles(self.last_lets) # ουσιαστικά η συνάρτηση αυτή καλεί την rmove_tiles με είσοδο
        return self.last_lets # την λίστα των πλακιδίων που προστέθηκαν τελευταία τα όποια τα αποθηκεύσαμε στην τελευταία κλήση της μεθόδου add_tiles

    def get_number_of_empty(self):
        """
        Η μέθοδος αυτή μας επιστρέφει τον αριθμό των κενών πλακιδίων. Αυτή είναι χρήσιμη, για να μπορούμε π.χ.
        να βγάζουμε από το σακουλάκι, όσα γράμματα μας λείπουν από τον δίσκο.
        Είσοδος: Κενό
        Έξοδος: Ο αριθμός των θέσεων της λίστας του δίσκου που είναι κενές
        """
        return len([i for i in self.rack if i == None]) #επιστρέφουμε τον αριθμό των θέσεων που έχουν τιμή None

class Player:
    """
    Η κλάση αυτή ορίζει την βασική δομή μιας κλάσης τύπου Παίχτη. Κάθε παίχτης πρέπει να μπορεί να επικοινωνεί με το σακουλάκι
    του παιχνιδιού και με τον διαιτητή όπως ακριβώς και στο πραγματικό - φυσικό παιχνίδι. Επίσης κάθε παίχτης έχει και ένα σκορ!
    """
    def __init__(self, sak, reg):
        """
        Η μέθοδος αυτή καλείται όταν κατασκευάζεται ένα στιγμιότυπο της κλάσης Player (η των παραγωγών τους αν δεν την έχουν κάνει override).
        Η μέθοδος αυτή είναι υπεύθυνη για την αρχικοποίηση του πλακιδίου του παίχτη, του σκορ κ.α.
        Είσοδος: Ένα αντικείμενο τύπου σακουλάκι και ένα αντικείμενο τύπου διαιτητή
        """
        self.sak = sak # δέχεται σαν είσοδο ένα σακουλάκι, για να μπορεί να επικοινωνεί ο παίχτης με αυτό
        self.reg = reg # δέχεται σαν είσοδο ένα αντικείμενο τύπου διαιτητή ο όποιος θα ελέγχει τις λέξεις του παίχτη αν είναι έγκυρες καθώς και πιο είναι το σκορ τους

        self.rack = Rack() # αρχικοποιούμε το ράφι μας με τα γράμματα
        self.rack.add_tiles(sak.getletters(7))
        self.score = 0 # αρχικοποιούμε το score του παίχτη με 0

    def __repr__(self):
        """
        Η κλάση αυτή επιστρέφει ένα ενδεικτικό κείμενο του στιγμιότυπού!
        """
        return "I am a Player!"


class Human(Player):
    """
    Η κλάση που προσομοιώνει τον παίχτη -  Άνθρωπο του παιχνιδιού scrabble!
    Η κλάση αυτή κληρονομεί τα χαρακτηριστικά της κλάσης Player (παίχτης).
    """
    def play(self):
        """
        Η μέθοδος αυτή προσομοιώνει την παρτίδα ενός παίχτη - Ανθρώπου στο παιχνίδι.
        Αρχικά τυπώνει το περιεχόμενα του πλακιδίου μαζί με το σκορ των γραμμάτων.
        Στην συνέχεια περιμένει μέχρι να διαβάσει από το Input είτε μια έγκυρη λέξη, είτε p δηλαδή πάσο είτε q δηλαδή παραίτηση.
        Είσοδος: Κενό
        Έξοδος: Ακέραιος που δηλώνει την έκβαση της παρτίδας του Ανθρώπου. Αν είναι 0 τότε όλα κύλησαν ομαλά και ο παίχτης
        ολοκλήρωσε επιτυχημένα την παρτίδα του, αν είναι -1 σημαίνει ότι η παρτίδα δεν τελείωσε π.χ. ο χρήστης παραιτήθηκε,
        οπότε και το παιχνίδι πρέπει να ολοκληρωθεί!
        """
        print (self.rack) # τυπώνουμε στον χρήστη τα γράμματα που έχει στο ράφι του
        while(True): # μέχρι κάτι να μας βγάλει από την loop
            word = input("Λέξη: ").strip() # διαβάζουμε μια λέξη από τον χρήστη και αφαιρούμε κενά ή \n στο τέλος ή στην αρχή
            if word == "p": # αν η λέξη είναι p ο παίχτης πάει πάσο όποτε:
                lets = self.rack.rollback() # αρχικά ο παίχτης βγάζει τα τελευταία γράμματα που επέλεξε από το ράφι του
                number_of_letters = self.rack.get_number_of_empty()
                new_lets = self.sak.getletters(number_of_letters) # στην συνέχεια επιλέγει καινούργια από το σακουλάκι
                self.sak.putbackletters(lets) # βάζουμε τα παλιά γράμματα του στο σακουλάκι
                self.rack.add_tiles(new_lets) # και τελικά βάζουμε τα νέα γράμματα που τράβηξε ο παίχτης από το σακουλάκι στο ράφι του
                print (f"Επιλογή: Πάσο, Βαθμοί: 0, Σκορ: {self.score}")
                break # τελειώνουμε την σειρά του παίχτη
            elif word  == "q":
                return -1 # σημαίνει ότι ο παίχτης παραιτείται από το παιχνίδι, επιστρέφουμε αντίστοιχο κωδικό

            # αν η λέξη που έδωσε ο χρήστης δεν είναι το πάσο τότε κάνουμε τα παρακάτω
            word = word.upper() # τα κάνουμε όλα κεφαλαία για να μην είμαστε case sensitive
            score, msg = self.reg.checkword(self.rack.rack, word) # ο διαιτητής ελέγχει αν η λέξη είναι έγκυρη
            if score != 0: # αν είναι έγκυρη τότε αυτό σημαίνει ότι το σκορ του είναι μεγαλύτερο του 0
                self.score += score # προσθέτουμε το σκορ της λέξης αυτής στο συνολικό σκορ του παίχτη
                print (msg, end = "") # εμφανίζουμε κατάλληλο μήνυμα
                print (f" - Σκορ: {self.score}")
                # στην συνέχεια αφαιρούμε τα γράμματα της λέξης από το ράφι του
                word_lets = [w for w in word]
                self.rack.remove_tiles(word_lets)
                number_of_letters = self.rack.get_number_of_empty() # βλέπουμε πόσα γράμματα λείπουν και στην συνέχεια
                lets = self.sak.getletters(number_of_letters) # βγάζουμε από το σακουλάκι τον αντίστοιχο αριθμό γραμμάτων
                self.rack.add_tiles(lets) # τα βάζουμε στο ράφι μας
                break # και τέλος σταματάμε την λούπα γιατί ολοκληρώθηκε η σειρά του παίχτη

            print (msg) # αν το σκορ δεν είναι 0 τότε εμφανίζουμε το κατάλληλο μήνυμα που μας επέστρεψε ο διαιτητής
            # και δίνουμε την ευκαιρία στον παίχτη να ξαναπαίξει και να διορθώσει το λάθος του
        return 0 # σημαίνει ότι το η σειρά του παίχτη ολοκληρώθηκε κανονικά!

class Computer(Player):
    """
    Η κλάση που προσομοιώνει τον παίχτη -  Υπολογιστή του παιχνιδιού scrabble!
    Η κλάση αυτή κληρονομεί τα χαρακτηριστικά της κλάσης Player (παίχτης).
    """
    def play(self, algorithm):
        """
        Η μέθοδος αυτή προσομοιώνει την παρτίδα ενός παίχτη - Υπολογιστή στο παιχνίδι.
        Αρχικά τυπώνει το περιεχόμενα του πλακιδίου μαζί με το σκορ των γραμμάτων.
        Στην συνέχεια καλεί τον κατάλληλο αλγόριθμο ο όποιος θα επιστρέψει την λέξη που θα παίξει ο υπολογιστής σύμφωνα με το Σενάριο 1 της εκφώνησης
        Αν δεν υπάρχει κάποια έγκυρη λέξη με τα γράμματα του υπολογιστή τότε το παιχνίδι λήγει!
        Είσοδος: Ένα str με τον τύπο του αλγορίθμου του υπολογιστή μεταξύ των min-max-smart, δηλαδή του Σεναρίου 1 της εκφώνησης
        Έξοδος: Ακέραιος που δηλώνει την έκβαση της παρτίδας του Ανθρώπου. Αν είναι 0 τότε όλα κύλησαν ομαλά και ο παίχτης
        ολοκλήρωσε επιτυχημένα την παρτίδα του, αν είναι -1 σημαίνει ότι η παρτίδα δεν τέλειωσε π.χ. δεν βρέθηκε λέξη με τα γράμματα του δίσκου,
        οπότε και το παιχνίδι πρέπει να ολοκληρωθεί!
        """
        self.algorithm = algorithm # σώζουμε τον τύπο του αλγόριθμο με τον όποιον παίζει ο υπολογιστής
        print (self.rack) # τυπώνουμε στον χρήστη τα γράμματα που έχει στο ράφι του
        if self.algorithm == "min": # αν είναι min τότε κάλεσε τον min
            word, score = self.min_algorithm() # αν ο επιλεγμένος αλγόριθμος είναι ο max τότε κάλεσε τον max
        elif self.algorithm == "max":
            word, score = self.max_algorithm()
        else: # αλλιώς τον smart. Δεν θέλουμε να βγάλουμε error αν κάτι έχει πάει για κάποιον λόγο λάθος και περάσει ένας τύπος αλγορίθμου που δεν είναι αποδεκτός, πράγμα που δεν γίνεται αλλά σε κάθε περίπτωση ο default αλγόριθμος θέλουμε να είναι ο smart
            word, score = self.smart_algorithm()

        if score > 0: # αν το σκορ είναι μεγαλύτερο του μηδενός, δηλαδή βρήκαμε κάποια έγκυρη λέξη τότε
            self.score += score # προσθέτουμε το σκορ της λέξης στο σκορ μας

            lets = [w for w in word] # αποθηκεύουμε τα γράμματα τις λέξης σε μια λίστα
            self.rack.remove_tiles(lets) # αφαιρούμε τα γράμματα αυτά από το πλακίδιό μας
            number_of_letters = self.rack.get_number_of_empty() # βλέπουμε πόσα γράμματα λείπουν και στην συνέχεια
            lets = self.sak.getletters(number_of_letters) # βγάζουμε από το σακουλάκι τον αντίστοιχο αριθμό γραμμάτων
            self.rack.add_tiles(lets) # και τα βάζουμε στο πλακίδιό μας
            print (f"Λέξη Η/Υ: {word}, Βαθμοί: {score}, Σκόρ: {self.score} ") # τυπώνουμε κατάλληλο μήνυμα
            return 0 # σημαίνει ότι ο υπολογιστής ολοκλήρωσε κανονικά την σειρά του
        else:
            print () # τυπώνουμε μια αλλαγή γραμμής
            print ("Δεν κατάφερα να βρω λέξη με αυτά τα γράμματα! Παραιτούμαι! Νίκησες!")
            return -1 # σημαίνει ότι ο υπολογιστής παραιτείται, γιατί δεν μπορεί να παράγει κάποια νέα λέξη


    def min_algorithm(self):
        """
        Ο min αλγόριθμος ξεκινά από τις λέξεις με 2 γράμματα μέχρι και με 7 και στην πρώτη λέξη που βρίσκει και είναι αποδεκτή (δηλαδή ανήκει στο greek7.txt) την επιστρέφει μαζί με το σκορ της
        Αν δεν βρεθεί κάποια λέξη τότε επιστρέφει σαν λέξη την end και σαν σκορ 0
        Είσοδος: Κενό
        Έξοδος: την λέξη που βρήκε (ή end) και το σκορ της (ή 0)
        """
        lets = self.rack.rack # κρατάμε τα γράμματα του πλακιδίου
        for length in range (2, 7): # από το μέγεθος 2 μέχρι το 7
            subsets = findsubsets(lets, length) # βρίσκουμε όλα τα subsets για τα γράμματα του πλακιδίου με μήκος 2
            for sub in subsets: # για κάθε ένα subset
                for rearrange in findrearranges(sub): # βρίσκουμε όλες τις πιθανές λέξεις με αυτά τα γράμματα
                    word = "".join(rearrange) # κάνουμε την λίστα γραμμάτων μια λέξη
                    score, _ = self.reg.checkword(self.rack.rack, word) # υπολογίζουμε το σκορ της και αδιαφορούμε για το μήνυμα που επιστρέφεται
                    if score != 0: # αν είναι μεγαλύτερο του 0 την πρώτη φορά σταματάμε, δηλαδή στην μικρότερη λέξη
                        return word, score # επιστρέφουμε την λέξη με το σκορ
        # ο υπολογιστής δεν βρήκε καμία λέξη!
        return "end", 0 # αλλιώς αν τρέξουμε όλες τις πιθανές λέξεις και δεν βρούμε τίποτα επιστρέφουμε σφάλμα

    def max_algorithm(self):
        """
        Ο max αλγόριθμος ξεκινά από τις λέξεις με 7 γράμματα μέχρι και με 2 και στην πρώτη λέξη που βρίσκει και είναι αποδεκτή (δηλαδή ανήκει στο greek7.txt) την επιστρέφει μαζί με το σκορ της
        Αν δεν βρεθεί κάποια λέξη τότε επιστρέφει σαν λέξη την end και σαν σκορ 0
        Είσοδος: Κενό
        Έξοδος: την λέξη που βρήκε (ή end) και το σκορ της (ή 0)
        """
        lets = self.rack.rack # κρατάμε τα γράμματα του πλακιδίου
        for length in range (7, 2, -1): # από το μέγεθος 7 μέχρι το 2
            subsets = findsubsets(lets, length) # βρίσκουμε όλα τα subsets για τα γράμματα του πλακιδίου με μήκος 2
            for sub in subsets: # για κάθε ένα subset
                for rearrange in findrearranges(sub): # βρίσκουμε όλες τις πιθανές λέξεις με αυτά τα γράμματα
                    word = "".join(rearrange) # κάνουμε την λίστα γραμμάτων μια λέξη
                    score, _ = self.reg.checkword(self.rack.rack, word) # υπολογίζουμε το σκορ της και αδιαφορούμε για το μήνυμα που επιστρέφεται
                    if score != 0: # αν είναι μεγαλύτερο του 0 την πρώτη φορά σταματάμε, δηλαδή στην μεγαλύτερη λέξη
                        return word, score # επιστρέφουμε την λέξη με το σκορ
        # ο υπολογιστής δεν βρήκε καμία λέξη!
        return "end", 0 # αλλιώς αν τρέξουμε όλες τις πιθανές λέξεις και δεν βρούμε τίποτα επιστρέφουμε σφάλμα


    def smart_algorithm(self):
        """
        Ο smart αλγόριθμος ξεκινά από τις λέξεις με 2 γράμματα μέχρι και με 7 και
        βρίσκει όλες τις λέξεις αλλά επιστρέφει αυτή που θα του δώσει το μεγαλύτερο σκορ
        Αν δεν βρεθεί κάποια λέξη τότε επιστρέφει σαν λέξη την end και σαν σκορ 0
        Είσοδος: Κενό
        Έξοδος: την λέξη που βρήκε (ή end) και το σκόρ της (ή 0)
        """
        lets = self.rack.rack # κρατάμε τα γράμματα του πλακιδίου
        max_score, max_word = 0, "end" # αρχικοποιούμε την μέγιστη λέξη και το μέγιστο σκορ
        for length in range (2, 7): # για κάθε ένα μέγεθος από 2 μέχρι 7
            subsets = findsubsets(lets, length) # βρίσκουμε όλα τα subsets για τα γράμματα του πλακιδίου με μήκος 2
            for sub in subsets:
                for rearrange in findrearranges(sub):# βρίσκουμε όλες τις πιθανές λέξεις με αυτά τα γράμματα
                    word = "".join(rearrange) # κάνουμε την λίστα γραμματων μια λέξη
                    score, _ = self.reg.checkword(self.rack.rack, word) # υπολογίζουμε το σκόρ της και αδιαφορούμε για το μήνυμα που επιστρέφεται
                    if score != 0: # βρίσκουμε όλες τις πιθανές λέξεις με αυτά τα γράμματα
                        word = "".join(rearrange) # κάνουμε την λίστα γραμματων μια λέξη
                        score, _ = self.reg.checkword(self.rack.rack, word) # υπολογίζουμε το σκόρ της και αδιαφορούμε για το μήνυμα που επιστρέφεται
                    if score > max_score: # αν το σκορ της τρέχουσας λέξης είναι μεγαλύτερο από αυτό του μεγαλυτ΄ρου που εχουμε βρει μέχρι στιγμής
                        max_score = score # βάοζυμε σαν μεγαλύετερο σκορ αυτό της τρέχουσας λέξης
                        max_word = word # και σαν λέξη με το μεγαλύτερο σκορ την τρέχουσα λέξη
        return max_word, max_score  # βρούμε δεν βρούμε λέξη επιστρέφουμε την λέξη με το μεγαλύτερο σκορ και το σκορ της
        # αν δεν βρούμε καμία λέξη τότε αυτό σημαίνει ότι θα έχουν μείνει τα αρχικά που είναι το end και 0 όπως ακριβώς θέλαμε

class Game:
    """
    Η κλάση αυτή είναι υπεύθυνη για την λειτουργία του παιχνιδιού
    """
    def __init__(self, computer_method, filename):
        """
        Η συνάρτηση αυτή καλείται κάθε φορά που κατασκευάζεται ένα αντικείμενο Game και στην ουσία κάνει ένα
        πρώτο setup στο παιχνίδι, φορτώνοντας και κατασκευάζοντας ότι πρέπει να κατασκευαστεί
        Εισόδος: Μέθοδος υπολογιστή ένα str μεταξύ min, max, smart και το αρχείο json στο όποιο θα αποθηκεύουμε τα αποτελέσματα του παιχνιδιού
        """
        self.computer_method = computer_method
        self.filename = filename
        self.turns = 0 # ο αριθμός των παρτίδων που παίχτηκαν στο συγκεκριμένο παιχνίδι
        self.setup() # αρχικά σετάρουμε το παιχνίδι
        pass


    def __repr__(self):
        """
        Η μέθοδος αυτή τυπώνει μερικά βασικά στοιχεία του παιχνιδιού όπως το σκορ και οι παρτίδες που έχουν παιχτεί.
        """
        return f"Έχουν παιχτεί {turns} παρτίδες και το σκορ του παιχνιδιού είναι: {self.human.score}-{self.computer.score} άνθρωπος-υπολογιστής!"

    def setup(self):
        """
        Η μέθοδος αυτή κάνει ένα αρχικό setup του παιχνιδιού. Σε αυτό περιλαμβάνεται η κατασκευή του σακουλάκιου, η κατασκευή του διαιτητή,
        καθώς και των 2 παιχτών του παιχνιδιού, του ανθρώπου και του υπολογιστή.
        """
        self.sak = SakClass() # αρχικά κατασκευάζεται μια δομή τύπου σακουλάκι
        #επίσης ορίζουμε και τον υπεύθυνο - διαιτητή του παιχνιδιού ο όποιος θα είναι υπεύθυνος για τον έλεγχο των λέξεων τον πόντων κ.α.
        self.reg = Regulator()

        self.human = Human(self.sak, self.reg) # ορίζουμε τον παίχτη-άνθρωπο
        self.computer = Computer(self.sak, self.reg) # ορίζουμε τον παίχτη- υπολογιστή

    def run(self):
        """
        Η μέθοδος αυτή τρέχει ουσιαστικά το παιχνίδι δίνοντας σειρά κάθε φορά στον άνθρωπο ή στον υπολογιστή να παίξει
        Κάθε φορά ελέγχει τον κωδικό που επιστρέφει η παρτίδα κάθε παίχτη και ελέγχει αν πρέπει να σταματήσει την εκτέλεση του παιχνιδιού ή όχι
        Είσοδος: Κενό
        Έξοδος: Κενό
        """
        try:
            # αρχικά παίζει ο παίχτης
            # επιλέγουμε τα γράμματά του
            while (True): # μέχρι κάτι να μας βγάλει εκτός λούπας
                print (f"Στο σακουλάκι: {self.sak.saksize()} γράμματα - Παίζεις:") # αρχικά παίζει ο χρήστης, όποτε τυπώνουμε κατάλληλο μήνυμα
                player_code = self.human.play() # και του δίνουμε την σειρά του να παίξει
                if player_code != 0: # αν η παρτίδα του δεν ολοκληρωθεί σωστά, δηλαδή πατήσει το q
                    print ("Η παρτίδα τελείωσε αφού ο χρήστης παραιτήθηκε!") # εμφανίζουμε κατάλληλο μήνυμα
                    self.human.score = -1  # 'βάζουμε' σαν σκόρ το -1 γιατί ο άνθρωπος παραιτήθηκε!
                    break # και βγαίνουμε από την λούπα
                input("Enter για συνέχεια") # περιμένουμε ο χρήστης να δει το σκορ του και να πατήσει Enter όπως στην εκφώνηση
                print ("------------------------------------------------------------------------------------------------------")
                print (f"Στο σακουλάκι: {self.sak.saksize()} γράμματα - Παίζει ο Υ/Π:") # αφού πατήσει Enter σειρά του υπολογιστή, όποτε τυπώνουμε κατάλληλο μήνυμα
                computer_code = self.computer.play(self.computer_method) # ο υπολογιστής παίζει με την μέθοδο που έχει επιλέξει ο χρήστης
                print ("------------------------------------------------------------------------------------------------------")
                if computer_code != 0: # αν η παρτίδα του δεν ολοκληρωθεί καλά, δηλαδή ο υπολογιστής δεν βρει λέξη
                    print ("Η παρτίδα τελείωσε αφού ο υπολογιστής παραιτήθηκε!") # ανακοινώνουμε ότι η παρτίδα τελείωσε
                    self.computer.score = -1 # 'βάζουμε' σαν σκόρ το -1 γιατί ο υπολογιστής παραιτήθηκε!
                    break # και βγαίνουμε από την λούπα
                self.turns += 1 # αυξάνουμε τον αριθμό των γύρων κατά 1
        except Exception as msg: # γενικά χειριζόμαστε εξαιρέσεις μήπως κάτι πάει λάθος να μπορούμε να ξαναρχίσουμε το παιχνίδι αλλά και το παιχνίδι λήξει λόγω έλλειψης γραμμάτων έτσι το καταλαβαίνουμε
            # εδώ έχουμε τελειώσει με το παιχνίδι μιας και δεν έχουμε να αντικαταστήσουμε τα γράμματα που βγήκαν!
            print (msg)
        # Σε αυτό το σημείο σημαίνει ότι το παιχνίδι έχει ολοκληρωθεί όποτε συνεχίζουμε με τις ενέργειες για να σώσουμε τα αποτελέσματα
        self.end() # καλούμε την μέθοδο end για να λήξουμε το παιχνίδι

    def end(self):
        """
        Η μέθοδος αυτή είναι υπεύθυνη για την εμφάνιση κατάλληλων μηνυμάτων στον χρήστη στο τέλος του παιχνιδιού,
        αλλά και στην αποθήκευση των χρήσιμων πληροφοριών στο αρχείο json
        Είσοδος: Κενό
        Έξοδος: Κενό
        """
        # εμφανίζουμε κατάλληλα μηνύματα στον χρήστη
        if self.human.score > self.computer.score:
            print ("Νικητής: Άνθρωπος! Συγχαρητήρια!")
        elif self.human.score < self.computer.score:
            print ("Νικητής: Υ/Π!")
        else:
            print ("Ισοπαλία!")

        # παράλληλα με την εμφάνιση των μηνυμάτων σώζουμε και μερικά απαραίτητα στατιστικά για το παιχνίδι στο filename που δόθηκε σαν είσοδος
        if os.path.exists(self.filename): # αν το αρχείο υπάρχει φορτώνουμε τα δεδομένα του
            data = load_json(self.filename) # στην μεταβλητή data
        else: # αν δεν έχει δεδομένα το αρχείο μας αρχικοποιούμε με την παρακάτω δομή
            data = [] # αν δεν υπάρχει αρχικοποιούμε την συγκεκριμένη μεταβλητή

        # τα στατιστικά που αποθηκεύουμε για το παιχνίδι είναι
        # το σκορ των παιχτών, ο αριθμός των παρτίδων του και η μέθοδος με την όποια έπαιζε ο υπολογιστής
        data.append({"human_score": self.human.score,
                    "computer_score": self.computer.score,
                    "turns": self.turns,
                    "computer_method": self.computer_method})
        save_json(data, self.filename) # σώζουμε τα δεδομένα στην μνήμη στο ίδιο αρχείο json (αν δεν υπάρχει το φτιάχνουμε)

        print (f"Τελικό Σκορ: Άνθρωπος {self.human.score} - Y/Π {self.computer.score} \n") # αφού τα κάνουμε όλα, εμφανίζουμε το τελικό σκορ!
